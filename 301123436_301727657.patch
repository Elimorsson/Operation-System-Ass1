diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..20713b4
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,29 @@
+{
+    // Use IntelliSense to learn about possible attributes.
+    // Hover to view descriptions of existing attributes.
+    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "name": "gcc-7 - Build and debug active file",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${fileDirname}/${fileBasenameNoExtension}",
+            "args": [],
+            "stopAtEntry": false,
+            "cwd": "${workspaceFolder}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                }
+            ],
+            "preLaunchTask": "gcc-7 build active file",
+            "miDebuggerPath": "/usr/bin/gdb"
+        }
+    ]
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..4452305
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,6 @@
+{
+    "files.associations": {
+        "cstdlib": "c",
+        "string.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..af3a1f6
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,19 @@
+{
+    "tasks": [
+        {
+            "type": "shell",
+            "label": "gcc-7 build active file",
+            "command": "/usr/bin/gcc-7",
+            "args": [
+                "-g",
+                "${file}",
+                "-o",
+                "${fileDirname}/${fileBasenameNoExtension}"
+            ],
+            "options": {
+                "cwd": "/usr/bin"
+            }
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/301123436_301727657.patch b/301123436_301727657.patch
new file mode 100644
index 0000000..e69de29
diff --git a/Makefile b/Makefile
index 09d790c..fca58ab 100644
--- a/Makefile
+++ b/Makefile
@@ -166,6 +166,11 @@ mkfs: mkfs.c fs.h
 .PRECIOUS: %.o
 
 UPROGS=\
+	_sanity\
+	_policy\
+	_pTest\
+	_checkWait\
+	_helloworld\
 	_cat\
 	_echo\
 	_forktest\
@@ -181,6 +186,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_memsizetest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -248,7 +254,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c helloworld.c memsizetest.c checkWait.c pTest.c policy.c sanity.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff --git a/cat.c b/cat.c
index 5ddc820..ed1987d 100644
--- a/cat.c
+++ b/cat.c
@@ -12,12 +12,12 @@ cat(int fd)
   while((n = read(fd, buf, sizeof(buf))) > 0) {
     if (write(1, buf, n) != n) {
       printf(1, "cat: write error\n");
-      exit();
+      exit(0);
     }
   }
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit();
+    exit(0);
   }
 }
 
@@ -28,16 +28,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     cat(fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/checkWait.c b/checkWait.c
new file mode 100644
index 0000000..b77d8b9
--- /dev/null
+++ b/checkWait.c
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   if (fork() == 0){
+       exit(0);
+   }
+   int status = -12;
+   wait(&status);
+   printf(1, "the status is %d\n", status);
+   exit(0);
+}
diff --git a/defs.h b/defs.h
index 82fb982..6416c03 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,9 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct perf;
+
+int sched_type;
 
 // bio.c
 void            binit(void);
@@ -104,7 +107,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 int             cpuid(void);
-void            exit(void);
+void            exit(int status);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -117,9 +120,10 @@ void            sched(void);
 void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(void);
+int             wait(int *status);
 void            wakeup(void*);
 void            yield(void);
+int             proc_info(struct perf*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/echo.c b/echo.c
index 806dee0..eed68a0 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
+  exit(0);
 }
diff --git a/forktest.c b/forktest.c
index 8bc984d..16ab957 100644
--- a/forktest.c
+++ b/forktest.c
@@ -16,6 +16,7 @@ printf(int fd, const char *s, ...)
 void
 forktest(void)
 {
+  int status;
   int n, pid;
 
   printf(1, "fork test\n");
@@ -25,24 +26,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(0);
   }
 
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit();
+    exit(0);
   }
 
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(&status) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(0);
     }
   }
 
-  if(wait() != -1){
+  if(wait(&status) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "fork test OK\n");
@@ -52,5 +53,5 @@ int
 main(void)
 {
   forktest();
-  exit();
+  exit(0);
 }
diff --git a/grep.c b/grep.c
index adc4835..1aa1081 100644
--- a/grep.c
+++ b/grep.c
@@ -43,24 +43,24 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit();
+    exit(0);
   }
   pattern = argv[1];
 
   if(argc <= 2){
     grep(pattern, 0);
-    exit();
+    exit(0);
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit();
+  exit(0);
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/helloworld.c b/helloworld.c
new file mode 100644
index 0000000..b62a436
--- /dev/null
+++ b/helloworld.c
@@ -0,0 +1,10 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    printf(1,"Hello my World %s \n", "Xv6");
+  exit(0);
+}
diff --git a/init.c b/init.c
index 046b551..5ce25e3 100644
--- a/init.c
+++ b/init.c
@@ -10,7 +10,7 @@ char *argv[] = { "sh", 0 };
 int
 main(void)
 {
-  int pid, wpid;
+  int pid, wpid,status;
 
   if(open("console", O_RDWR) < 0){
     mknod("console", 1, 1);
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit();
+      exit(0);
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit();
+      exit(0);
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+    while((wpid=wait(&status)) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/kill.c b/kill.c
index 364f6af..5a2e450 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 2){
     printf(2, "usage: kill pid...\n");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit();
+  exit(0);
 }
diff --git a/ln.c b/ln.c
index cf8a64e..14acdc8 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit();
+    exit(0);
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
+  exit(0);
 }
diff --git a/ls.c b/ls.c
index 2862913..27742c2 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit();
+    exit(0);
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit();
+  exit(0);
 }
diff --git a/memsizetest.c b/memsizetest.c
new file mode 100644
index 0000000..14009dc
--- /dev/null
+++ b/memsizetest.c
@@ -0,0 +1,18 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+
+  int size = memsize();
+  printf(1,"the process is using: %d \n", size);
+  int* newPlace = (int*) malloc(2048);
+  size = memsize();
+  printf(1,"the process is using: %d \n", size);
+  free(newPlace);
+  size = memsize();
+  printf(1,"the process is using: %d \n", size);
+  exit(0);
+}
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..d101838 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/mkfs.c b/mkfs.c
index 8e011a7..e14ca21 100644
--- a/mkfs.c
+++ b/mkfs.c
@@ -78,7 +78,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     fprintf(stderr, "Usage: mkfs fs.img files...\n");
-    exit(1);
+    exit(0);
   }
 
   assert((BSIZE % sizeof(struct dinode)) == 0);
@@ -87,7 +87,7 @@ main(int argc, char *argv[])
   fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
   if(fsfd < 0){
     perror(argv[1]);
-    exit(1);
+    exit(0);
   }
 
   // 1 fs block = 1 disk sector
@@ -132,7 +132,7 @@ main(int argc, char *argv[])
 
     if((fd = open(argv[i], 0)) < 0){
       perror(argv[i]);
-      exit(1);
+      exit(0);
     }
 
     // Skip leading _ in name when writing to file system.
@@ -172,11 +172,11 @@ wsect(uint sec, void *buf)
 {
   if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
     perror("lseek");
-    exit(1);
+    exit(0);
   }
   if(write(fsfd, buf, BSIZE) != BSIZE){
     perror("write");
-    exit(1);
+    exit(0);
   }
 }
 
@@ -212,11 +212,11 @@ rsect(uint sec, void *buf)
 {
   if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
     perror("lseek");
-    exit(1);
+    exit(0);
   }
   if(read(fsfd, buf, BSIZE) != BSIZE){
     perror("read");
-    exit(1);
+    exit(0);
   }
 }
 
diff --git a/pTest.c b/pTest.c
new file mode 100644
index 0000000..31b524f
--- /dev/null
+++ b/pTest.c
@@ -0,0 +1,38 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+int main(int argc, char *argv[]) {
+  int pid;
+  int k, n;
+  int x, z;
+
+  policy(2);
+  if (argc != 2) {
+    printf(2, "usage: %s n\n", argv[0]);
+  }
+
+  n = atoi(argv[1]);
+
+  for ( k = 0; k < n; k++ ) {
+    pid = fork ();
+    if ( pid < 0 ) {
+      printf(1, "%d failed in fork!\n", getpid());
+      exit(0);
+    } else if (pid == 0) {
+      // child
+      printf(1, "Child %d created\n",getpid());
+      for ( z = 0; z < 100.0; z += 1 )
+         x =  x + 3.14 * 89.64;   // useless calculations to consume CPU time
+      exit(0);
+    }
+  }
+
+  for (k = 0; k < n; k++) {
+    wait(0);
+  }
+
+  exit(0);
+}
diff --git a/policy.c b/policy.c
new file mode 100644
index 0000000..77ad275
--- /dev/null
+++ b/policy.c
@@ -0,0 +1,14 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+if (argc != 2){
+    exit(1);
+ }
+  int n = atoi(argv[1]);
+  policy(n);
+  exit(0);
+}
diff --git a/proc.c b/proc.c
index 806b1b1..2789218 100644
--- a/proc.c
+++ b/proc.c
@@ -65,6 +65,23 @@ myproc(void) {
   return p;
 }
 
+long long findMinAcc() {
+  struct proc *p1;
+  long long minAcc = 9223372036854775807; //value of max long long 
+
+
+  for(p1 = ptable.proc; p1 < &ptable.proc[NPROC]; p1++){
+    if (p1->state != RUNNABLE)
+      continue;
+    if (p1->accumulator < minAcc)
+      minAcc = p1->accumulator;
+  }
+  if (minAcc != 9223372036854775807)
+    return minAcc;
+
+  return 0;
+}
+
 //PAGEBREAK: 32
 // Look in the process table for an UNUSED proc.
 // If found, change state to EMBRYO and initialize
@@ -76,6 +93,7 @@ allocproc(void)
   struct proc *p;
   char *sp;
 
+
   acquire(&ptable.lock);
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
@@ -87,7 +105,15 @@ allocproc(void)
 
 found:
   p->state = EMBRYO;
+  p->accumulator = 0;
+  long long minAcc = findMinAcc();
+  p->accumulator = minAcc;
+  p->ps_priority = 5;
   p->pid = nextpid++;
+  p->rtime = 0;
+  p->stime = 0;
+  p->retime = 0;
+  p->cfs_priority = 1;
 
   release(&ptable.lock);
 
@@ -149,6 +175,8 @@ userinit(void)
   acquire(&ptable.lock);
 
   p->state = RUNNABLE;
+  p->status = -1;
+
 
   release(&ptable.lock);
 }
@@ -174,6 +202,19 @@ growproc(int n)
   return 0;
 }
 
+int
+proc_info(struct perf* performance){
+
+  //struct perf* myPerf = myproc()->perf;
+  acquire(&ptable.lock);
+  performance->ps_priority = myproc()->ps_priority;
+  performance->stime = myproc()->stime;
+  performance->rtime = myproc()->rtime;
+  performance->retime = myproc()->retime;
+  release(&ptable.lock);
+  return 0;
+}
+
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
@@ -196,6 +237,8 @@ fork(void)
     np->state = UNUSED;
     return -1;
   }
+  np->cfs_priority = curproc->cfs_priority;
+  np->ps_priority = curproc->ps_priority;
   np->sz = curproc->sz;
   np->parent = curproc;
   *np->tf = *curproc->tf;
@@ -225,7 +268,7 @@ fork(void)
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(void)
+exit(int status)
 {
   struct proc *curproc = myproc();
   struct proc *p;
@@ -248,7 +291,6 @@ exit(void)
   curproc->cwd = 0;
 
   acquire(&ptable.lock);
-
   // Parent might be sleeping in wait().
   wakeup1(curproc->parent);
 
@@ -263,6 +305,7 @@ exit(void)
 
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
+  curproc->status = status;
   sched();
   panic("zombie exit");
 }
@@ -270,7 +313,7 @@ exit(void)
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
+wait(int *status)
 {
   struct proc *p;
   int havekids, pid;
@@ -287,6 +330,9 @@ wait(void)
       if(p->state == ZOMBIE){
         // Found one.
         pid = p->pid;
+        if (status != NULL){
+          *status = p->status;
+        }
         kfree(p->kstack);
         p->kstack = 0;
         freevm(p->pgdir);
@@ -311,6 +357,31 @@ wait(void)
   }
 }
 
+//assitance function
+//return smallest time ratio process
+struct proc* calculateRatio(struct proc* highP, struct proc* p1){
+float highPRatio,p1Ratio;
+
+int highPDen = highP->retime + highP->rtime + highP->stime;
+if (highPDen != 0){
+  highPRatio = (highP->rtime * highP->cfs_priority) / highPDen;
+}
+else {highPRatio = 1;}
+
+int p1Den = p1->retime + p1->rtime + p1->stime;
+if (p1Den != 0){
+  p1Ratio = (p1->rtime * p1->cfs_priority) / p1Den;
+}
+else {p1Ratio = 1;}
+
+if (p1Ratio < highPRatio){
+  //cprintf("pid: %d \t ratio: %f \n",highP->pid, p1Ratio);
+  return p1;
+}
+//cprintf("pid: %d \t ratio: %f \n",highP->pid, highPRatio);
+return highP;
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -322,27 +393,73 @@ wait(void)
 void
 scheduler(void)
 {
-  struct proc *p;
+  struct proc *p, *p1, *highP = NULL;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+  sched_type = 0;
+
+//cprintf("In sched before the for loop\n");
   for(;;){
     // Enable interrupts on this processor.
     sti();
+    //cprintf("In sched inside the for loop\n");
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
+
+      if(sched_type == 0){
+          //cprintf("%p \t In sched type 0\n",p);
+          if(p->state != RUNNABLE){
+            //cprintf("continue\n");
+            continue;
+          }
+            
+      }
+      else if(sched_type == 1){
+          if(p->state != RUNNABLE){
+            continue;
+          }
+             //  highP indicate the procces with the high priority right now
+            highP = p;
+              //   choose proccess with highest priority
+            for(p1 = ptable.proc; p1< &ptable.proc[NPROC]; p1++){
+              if (p1->state != RUNNABLE)
+                continue;
+              if ( highP->accumulator > p1->accumulator )
+                highP = p1;
+             }
+             p = highP;
+             //cprintf("pid: %d\t accumulator: %ld\t ps_priority: %d \n",p->pid, p->accumulator, p->ps_priority);
+            
+      }
+      else if(sched_type == 2){
+        if(p->state != RUNNABLE){
+          continue;
+        }
+        highP = p;
+        for(p1 = ptable.proc; p1< &ptable.proc[NPROC]; p1++){
+          if (p1->state != RUNNABLE)
+            continue;
+          highP = calculateRatio(highP, p1);
+        }
+        p = highP;
+      }
+      else
+      {
+        cprintf("faild to choose policy\n");
+        exit(1);
+      }
+      
+
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
+      //cprintf("In sched after for loop");
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
-
       swtch(&(c->scheduler), p->context);
       switchkvm();
 
@@ -386,7 +503,10 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+  struct proc *p = myproc();
+  p->state = RUNNABLE;
+  p->accumulator += p->ps_priority;
+  //cprintf("pid: %d\t accumulator: %d\t ps_priority: %d ratio: %d, \n", p->pid, p->accumulator, p->ps_priority);
   sched();
   release(&ptable.lock);
 }
@@ -460,8 +580,12 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+    if(p->state == SLEEPING && p->chan == chan){
       p->state = RUNNABLE;
+      long long minAcc = findMinAcc();
+      p->accumulator = minAcc;
+    }
+
 }
 
 // Wake up all processes sleeping on chan.
@@ -532,3 +656,68 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+void updatePerf() {
+  struct proc *p;
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    switch(p->state) {
+      case SLEEPING:
+        p->stime++;
+        break;
+      case RUNNABLE:
+        p->retime++;
+        break;
+      case RUNNING:
+        p->rtime++;
+        break;
+      default:
+        ;
+    }
+  }
+  release(&ptable.lock);
+}
+
+
+int 
+policy(int pType){
+
+  switch(pType){
+    case 0:
+      cprintf("Policy has been successfully changed to Default Policy\n");
+      break;
+    case 1:
+      cprintf("Policy has been successfully changed to Priority Policy\n");
+      break;
+    case 2:
+      cprintf("Policy has been successfully changed to CFS Policy\n");
+      break;
+    default:
+      cprintf("Error replacing policy, no such a policy number (%d)\n", pType);
+      return -1;
+  }
+    sched_type = pType;
+    return 0;
+
+}
+int set_cfs_priority(int factor){
+  struct proc* p = myproc();
+  switch(factor){
+    case 1:
+      p->cfs_priority = 0.75;
+      return 0;
+    case 2:
+      p->cfs_priority = 1;
+      return 0;
+    case 3:
+      p->cfs_priority = 1.25;
+      return 0;
+    default:
+      return -1;
+  }
+}
+
+int set_ps_priority(int newPriority){
+  myproc()->ps_priority = newPriority;
+  return 0;
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..136e52b 100644
--- a/proc.h
+++ b/proc.h
@@ -34,6 +34,8 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,8 +51,23 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int status;                  // Status of the process after terminated
+  long long accumulator;       // define the priority of the process
+  int cfs_priority;            // field for set priority at Completely Fair Schedular 
+  struct perf *perf;           // save performance date
+  int ps_priority;              // field for set priority
+  int rtime;                    // time process was in running state
+  int stime;                    // time process was in sleeping state
+  int retime;                   // time process was in ready/runnable state
+
 };
 
+
+void updatePerf();
+int policy(int pType);
+int set_cfs_priority(int factor);
+int set_ps_priority(int newPriority);
+
 // Process memory is laid out contiguously, low addresses first:
 //   text
 //   original data and bss
diff --git a/rm.c b/rm.c
index 4fd33c8..83c5f36 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(0);
 }
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..5eb1cc0
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,64 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+
+
+int main1(int argc, char *argv[]) {
+  int pid;
+  int k;
+  printf(1,"sanity:\n");
+  printf(1,"PID\tPS_PRIORITY\tSTIME\tRETIME\tRTIME\n");
+  
+  for ( k = 0; k < 3; k++ ) {
+    pid = fork ();
+    if ( pid < 0 ) {
+      printf(1, "%d failed in fork!\n", getpid());
+      exit(0);
+    } else if (pid == 0) {
+      // child
+        struct perf* performance = malloc(sizeof(struct perf));
+      switch(k){
+          case 0:
+            set_cfs_priority(3);
+            set_ps_priority(10);
+            break;
+          case 1:
+            set_cfs_priority(2);
+            set_ps_priority(5);
+            break;
+          case 2:
+            set_ps_priority(1);
+            set_cfs_priority(1);
+            break;
+      }
+      for (long long i = 0; i < 100; i += 1 ){
+         //x =  x + 3.14 * 89.64;  // useless calculations to consume CPU time
+         int  t1 = 0, t2 = 1, nextTerm;
+        long long z, n = 10000;
+        
+        for (z = 1; z <= n; ++z) {
+           // printf(0,"");
+           // printf(1,"");
+            nextTerm = t1 + t2;
+            t1 = t2;
+            t2 = nextTerm;
+        }
+      
+      }
+    printf(1,"%d\t",getpid());
+    proc_info(performance);
+    printf(1,"%d \t\t %d \t %d \t %d\n", performance->ps_priority, performance->stime, performance->retime, performance->rtime);
+      free(performance);
+      exit(0);
+    }
+  }
+  
+  for (k = 0; k < 3; k++) {
+    wait(0);
+  }
+
+  exit(0);
+}
+
diff --git a/sh.c b/sh.c
index 054bab9..5dbbcf5 100644
--- a/sh.c
+++ b/sh.c
@@ -57,6 +57,7 @@ struct cmd *parsecmd(char*);
 void
 runcmd(struct cmd *cmd)
 {
+  int status;
   int p[2];
   struct backcmd *bcmd;
   struct execcmd *ecmd;
@@ -65,7 +66,7 @@ runcmd(struct cmd *cmd)
   struct redircmd *rcmd;
 
   if(cmd == 0)
-    exit();
+    exit(0);
 
   switch(cmd->type){
   default:
@@ -74,7 +75,7 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      exit();
+      exit(0);
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -84,7 +85,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit();
+      exit(0);
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +94,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait();
+    wait(&status);
     runcmd(lcmd->right);
     break;
 
@@ -117,8 +118,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait();
-    wait();
+    wait(&status);
+    wait(&status);
     break;
 
   case BACK:
@@ -127,7 +128,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit();
+  exit(0);
 }
 
 int
@@ -145,7 +146,7 @@ int
 main(void)
 {
   static char buf[100];
-  int fd;
+  int fd, status;
 
   // Ensure that three file descriptors are open.
   while((fd = open("console", O_RDWR)) >= 0){
@@ -166,16 +167,16 @@ main(void)
     }
     if(fork1() == 0)
       runcmd(parsecmd(buf));
-    wait();
+    wait(&status);
   }
-  exit();
+  exit(0);
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit();
+  exit(0);
 }
 
 int
diff --git a/stat.h b/stat.h
index 8a80933..b103efe 100644
--- a/stat.h
+++ b/stat.h
@@ -9,3 +9,4 @@ struct stat {
   short nlink; // Number of links to file
   uint size;   // Size of file in bytes
 };
+
diff --git a/stressfs.c b/stressfs.c
index c0a4743..b7bec77 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -16,7 +16,7 @@
 int
 main(int argc, char *argv[])
 {
-  int fd, i;
+  int fd, i, status;
   char path[] = "stressfs0";
   char data[512];
 
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait();
+  wait(&status);
 
-  exit();
+  exit(0);
 }
diff --git a/syscall.c b/syscall.c
index ee85261..7cc85d2 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,11 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_memsize(void);
+extern int sys_set_ps_priority(void);
+extern int sys_set_cfs_priority(void);
+extern int sys_policy(void);
+extern int sys_proc_info(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_memsize] sys_memsize,
+[SYS_set_ps_priority] sys_set_ps_priority,
+[SYS_set_cfs_priority] sys_set_cfs_priority,
+[SYS_policy] sys_policy,
+[SYS_proc_info] sys_proc_info,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..c69c4e9 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_memsize 22
+#define SYS_set_ps_priority 23
+#define SYS_set_cfs_priority 24
+#define SYS_policy 25
+#define SYS_proc_info 26
diff --git a/sysproc.c b/sysproc.c
index 0686d29..23c3efe 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -16,14 +16,52 @@ sys_fork(void)
 int
 sys_exit(void)
 {
-  exit();
+  int status;
+  if(argint(0, &status) < 0)
+    return -1;
+  exit(status);
   return 0;  // not reached
 }
 
 int
 sys_wait(void)
 {
-  return wait();
+  int statusPTR;
+  if(argint(0, &statusPTR) < 0)
+    return -1;
+  return wait((int*) statusPTR);
+}
+
+int
+sys_set_ps_priority(void){
+  int newPriority;
+  if(argint(0, &newPriority) < 0)
+    return -1;
+  return set_ps_priority(newPriority);
+}
+
+int 
+sys_set_cfs_priority(void){
+  int factor;
+  if(argint(0, &factor) < 0)
+    return -1;
+  return set_cfs_priority(factor);
+}
+
+int sys_policy(void){
+  int pType;
+  if (argint(0, &pType) < 0){
+    return -1;
+  }
+  return policy(pType);
+  }  
+
+int 
+sys_proc_info(void){
+  char* performance;
+  if (argptr(0, &performance,sizeof(struct perf)) < 0)
+    return -1;
+  return proc_info((struct perf*) performance);
 }
 
 int
@@ -42,6 +80,12 @@ sys_getpid(void)
   return myproc()->pid;
 }
 
+int
+sys_memsize(void)
+{
+  return myproc()->sz;
+}
+
 int
 sys_sbrk(void)
 {
diff --git a/testi.c b/testi.c
new file mode 100644
index 0000000..7e9bda6
--- /dev/null
+++ b/testi.c
@@ -0,0 +1,11 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+
+    printf(1,"the process is using: %d \n", 6);
+  exit(0);
+}
diff --git a/trap.c b/trap.c
index 41c66eb..6be1557 100644
--- a/trap.c
+++ b/trap.c
@@ -38,11 +38,11 @@ trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
-      exit();
+      exit(0);
     myproc()->tf = tf;
     syscall();
     if(myproc()->killed)
-      exit();
+      exit(0);
     return;
   }
 
@@ -51,6 +51,7 @@ trap(struct trapframe *tf)
     if(cpuid() == 0){
       acquire(&tickslock);
       ticks++;
+      updatePerf();
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -94,11 +95,11 @@ trap(struct trapframe *tf)
     myproc()->killed = 1;
   }
 
-  // Force process exit if it has been killed and is in user space.
+  // Force process exit 0if it has been killed and is in user space.
   // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
@@ -108,5 +109,5 @@ trap(struct trapframe *tf)
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(0);
 }
diff --git a/types b/types
new file mode 100644
index 0000000..976cf58
Binary files /dev/null and b/types differ
diff --git a/types.h b/types.h
index e4adf64..b9cdd1b 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,15 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+struct perf {
+  int ps_priority;              // field for set priority
+  int rtime;                    // time process was in running state
+  int stime;                    // time process was in sleeping state
+  int retime;                   // time process was in ready/runnable state
+};
+
+
+#ifndef NULL
+#define NULL (void*) 0
+#endif
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..95f35f9 100644
--- a/user.h
+++ b/user.h
@@ -3,8 +3,8 @@ struct rtcdate;
 
 // system calls
 int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
+void exit(int status) __attribute__((noreturn));
+int wait(int *status);
 int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
@@ -23,6 +23,11 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int memsize(void);
+int set_ps_priority(int);
+int set_cfs_priority(int);
+int policy(int);
+int proc_info(struct perf*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usertests.c b/usertests.c
index a1e97e7..f4c5bf2 100644
--- a/usertests.c
+++ b/usertests.c
@@ -21,52 +21,52 @@ iputtest(void)
 
   if(mkdir("iputdir") < 0){
     printf(stdout, "mkdir failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("iputdir") < 0){
     printf(stdout, "chdir iputdir failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("../iputdir") < 0){
     printf(stdout, "unlink ../iputdir failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("/") < 0){
     printf(stdout, "chdir / failed\n");
-    exit();
+    exit(0);
   }
   printf(stdout, "iput test ok\n");
 }
 
-// does exit() call iput(p->cwd) in a transaction?
+// does exit(0) call iput(p->cwd) in a transaction?
 void
 exitiputtest(void)
 {
-  int pid;
+  int pid, status;
 
   printf(stdout, "exitiput test\n");
 
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit();
+    exit(0);
   }
   if(pid == 0){
     if(mkdir("iputdir") < 0){
       printf(stdout, "mkdir failed\n");
-      exit();
+      exit(0);
     }
     if(chdir("iputdir") < 0){
       printf(stdout, "child chdir failed\n");
-      exit();
+      exit(0);
     }
     if(unlink("../iputdir") < 0){
       printf(stdout, "unlink ../iputdir failed\n");
-      exit();
+      exit(0);
     }
-    exit();
+    exit(0);
   }
-  wait();
+  wait(&status);
   printf(stdout, "exitiput test ok\n");
 }
 
@@ -84,32 +84,32 @@ exitiputtest(void)
 void
 openiputtest(void)
 {
-  int pid;
+  int pid,status;
 
   printf(stdout, "openiput test\n");
   if(mkdir("oidir") < 0){
     printf(stdout, "mkdir oidir failed\n");
-    exit();
+    exit(0);
   }
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit();
+    exit(0);
   }
   if(pid == 0){
     int fd = open("oidir", O_RDWR);
     if(fd >= 0){
       printf(stdout, "open directory for write succeeded\n");
-      exit();
+      exit(0);
     }
-    exit();
+    exit(0);
   }
   sleep(1);
   if(unlink("oidir") != 0){
     printf(stdout, "unlink failed\n");
-    exit();
+    exit(0);
   }
-  wait();
+  wait(&status);
   printf(stdout, "openiput test ok\n");
 }
 
@@ -124,13 +124,13 @@ opentest(void)
   fd = open("echo", 0);
   if(fd < 0){
     printf(stdout, "open echo failed!\n");
-    exit();
+    exit(0);
   }
   close(fd);
   fd = open("doesnotexist", 0);
   if(fd >= 0){
     printf(stdout, "open doesnotexist succeeded!\n");
-    exit();
+    exit(0);
   }
   printf(stdout, "open test ok\n");
 }
@@ -147,16 +147,16 @@ writetest(void)
     printf(stdout, "creat small succeeded; ok\n");
   } else {
     printf(stdout, "error: creat small failed!\n");
-    exit();
+    exit(0);
   }
   for(i = 0; i < 100; i++){
     if(write(fd, "aaaaaaaaaa", 10) != 10){
       printf(stdout, "error: write aa %d new file failed\n", i);
-      exit();
+      exit(0);
     }
     if(write(fd, "bbbbbbbbbb", 10) != 10){
       printf(stdout, "error: write bb %d new file failed\n", i);
-      exit();
+      exit(0);
     }
   }
   printf(stdout, "writes ok\n");
@@ -166,20 +166,20 @@ writetest(void)
     printf(stdout, "open small succeeded ok\n");
   } else {
     printf(stdout, "error: open small failed!\n");
-    exit();
+    exit(0);
   }
   i = read(fd, buf, 2000);
   if(i == 2000){
     printf(stdout, "read succeeded ok\n");
   } else {
     printf(stdout, "read failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(unlink("small") < 0){
     printf(stdout, "unlink small failed\n");
-    exit();
+    exit(0);
   }
   printf(stdout, "small file test ok\n");
 }
@@ -194,14 +194,14 @@ writetest1(void)
   fd = open("big", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(stdout, "error: creat big failed!\n");
-    exit();
+    exit(0);
   }
 
   for(i = 0; i < MAXFILE; i++){
     ((int*)buf)[0] = i;
     if(write(fd, buf, 512) != 512){
       printf(stdout, "error: write big file failed\n", i);
-      exit();
+      exit(0);
     }
   }
 
@@ -210,7 +210,7 @@ writetest1(void)
   fd = open("big", O_RDONLY);
   if(fd < 0){
     printf(stdout, "error: open big failed!\n");
-    exit();
+    exit(0);
   }
 
   n = 0;
@@ -219,24 +219,24 @@ writetest1(void)
     if(i == 0){
       if(n == MAXFILE - 1){
         printf(stdout, "read only %d blocks from big", n);
-        exit();
+        exit(0);
       }
       break;
     } else if(i != 512){
       printf(stdout, "read failed %d\n", i);
-      exit();
+      exit(0);
     }
     if(((int*)buf)[0] != n){
       printf(stdout, "read content of block %d is %d\n",
              n, ((int*)buf)[0]);
-      exit();
+      exit(0);
     }
     n++;
   }
   close(fd);
   if(unlink("big") < 0){
     printf(stdout, "unlink big failed\n");
-    exit();
+    exit(0);
   }
   printf(stdout, "big files ok\n");
 }
@@ -270,22 +270,22 @@ void dirtest(void)
 
   if(mkdir("dir0") < 0){
     printf(stdout, "mkdir failed\n");
-    exit();
+    exit(0);
   }
 
   if(chdir("dir0") < 0){
     printf(stdout, "chdir dir0 failed\n");
-    exit();
+    exit(0);
   }
 
   if(chdir("..") < 0){
     printf(stdout, "chdir .. failed\n");
-    exit();
+    exit(0);
   }
 
   if(unlink("dir0") < 0){
     printf(stdout, "unlink dir0 failed\n");
-    exit();
+    exit(0);
   }
   printf(stdout, "mkdir test ok\n");
 }
@@ -296,7 +296,7 @@ exectest(void)
   printf(stdout, "exec test\n");
   if(exec("echo", echoargv) < 0){
     printf(stdout, "exec echo failed\n");
-    exit();
+    exit(0);
   }
 }
 
@@ -306,11 +306,11 @@ void
 pipe1(void)
 {
   int fds[2], pid;
-  int seq, i, n, cc, total;
+  int seq, i, n, cc, total, status;
 
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit();
+    exit(0);
   }
   pid = fork();
   seq = 0;
@@ -321,10 +321,10 @@ pipe1(void)
         buf[i] = seq++;
       if(write(fds[1], buf, 1033) != 1033){
         printf(1, "pipe1 oops 1\n");
-        exit();
+        exit(0);
       }
     }
-    exit();
+    exit(0);
   } else if(pid > 0){
     close(fds[1]);
     total = 0;
@@ -343,13 +343,13 @@ pipe1(void)
     }
     if(total != 5 * 1033){
       printf(1, "pipe1 oops 3 total %d\n", total);
-      exit();
+      exit(0);
     }
     close(fds[0]);
-    wait();
+    wait(&status);
   } else {
     printf(1, "fork() failed\n");
-    exit();
+    exit(0);
   }
   printf(1, "pipe1 ok\n");
 }
@@ -358,7 +358,7 @@ pipe1(void)
 void
 preempt(void)
 {
-  int pid1, pid2, pid3;
+  int pid1, pid2, pid3, status;
   int pfds[2];
 
   printf(1, "preempt: ");
@@ -394,17 +394,17 @@ preempt(void)
   kill(pid2);
   kill(pid3);
   printf(1, "wait... ");
-  wait();
-  wait();
-  wait();
+  wait(&status);
+  wait(&status);
+  wait(&status);
   printf(1, "preempt ok\n");
 }
 
-// try to find any races between exit and wait
+// try to find any races between exit 0and wait
 void
 exitwait(void)
 {
-  int i, pid;
+  int i, pid, status;
 
   for(i = 0; i < 100; i++){
     pid = fork();
@@ -413,12 +413,12 @@ exitwait(void)
       return;
     }
     if(pid){
-      if(wait() != pid){
+      if(wait(&status) != pid){
         printf(1, "wait wrong pid\n");
         return;
       }
     } else {
-      exit();
+      exit(0);
     }
   }
   printf(1, "exitwait ok\n");
@@ -428,7 +428,7 @@ void
 mem(void)
 {
   void *m1, *m2;
-  int pid, ppid;
+  int pid, ppid, status;
 
   printf(1, "mem test\n");
   ppid = getpid();
@@ -447,13 +447,13 @@ mem(void)
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
-      exit();
+      exit(0);
     }
     free(m1);
     printf(1, "mem ok\n");
-    exit();
+    exit(0);
   } else {
-    wait();
+    wait(&status);
   }
 }
 
@@ -464,7 +464,7 @@ mem(void)
 void
 sharedfd(void)
 {
-  int fd, pid, i, n, nc, np;
+  int fd, pid, i, n, nc, np, status;
   char buf[10];
 
   printf(1, "sharedfd test\n");
@@ -484,9 +484,9 @@ sharedfd(void)
     }
   }
   if(pid == 0)
-    exit();
+    exit(0);
   else
-    wait();
+    wait(&status);
   close(fd);
   fd = open("sharedfd", 0);
   if(fd < 0){
@@ -508,7 +508,7 @@ sharedfd(void)
     printf(1, "sharedfd ok\n");
   } else {
     printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit();
+    exit(0);
   }
 }
 
@@ -517,7 +517,7 @@ sharedfd(void)
 void
 fourfiles(void)
 {
-  int fd, pid, i, j, n, total, pi;
+  int fd, pid, i, j, n, total, pi, status;
   char *names[] = { "f0", "f1", "f2", "f3" };
   char *fname;
 
@@ -530,29 +530,29 @@ fourfiles(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(0);
     }
 
     if(pid == 0){
       fd = open(fname, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "create failed\n");
-        exit();
+        exit(0);
       }
 
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
           printf(1, "write failed %d\n", n);
-          exit();
+          exit(0);
         }
       }
-      exit();
+      exit(0);
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait();
+    wait(&status);
   }
 
   for(i = 0; i < 2; i++){
@@ -563,7 +563,7 @@ fourfiles(void)
       for(j = 0; j < n; j++){
         if(buf[j] != '0'+i){
           printf(1, "wrong char\n");
-          exit();
+          exit(0);
         }
       }
       total += n;
@@ -571,7 +571,7 @@ fourfiles(void)
     close(fd);
     if(total != 12*500){
       printf(1, "wrong length %d\n", total);
-      exit();
+      exit(0);
     }
     unlink(fname);
   }
@@ -584,7 +584,7 @@ void
 createdelete(void)
 {
   enum { N = 20 };
-  int pid, i, fd, pi;
+  int pid, i, fd, pi, status;
   char name[32];
 
   printf(1, "createdelete test\n");
@@ -593,7 +593,7 @@ createdelete(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(0);
     }
 
     if(pid == 0){
@@ -604,23 +604,23 @@ createdelete(void)
         fd = open(name, O_CREATE | O_RDWR);
         if(fd < 0){
           printf(1, "create failed\n");
-          exit();
+          exit(0);
         }
         close(fd);
         if(i > 0 && (i % 2 ) == 0){
           name[1] = '0' + (i / 2);
           if(unlink(name) < 0){
             printf(1, "unlink failed\n");
-            exit();
+            exit(0);
           }
         }
       }
-      exit();
+      exit(0);
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait();
+    wait(&status);
   }
 
   name[0] = name[1] = name[2] = 0;
@@ -631,10 +631,10 @@ createdelete(void)
       fd = open(name, 0);
       if((i == 0 || i >= N/2) && fd < 0){
         printf(1, "oops createdelete %s didn't exist\n", name);
-        exit();
+        exit(0);
       } else if((i >= 1 && i < N/2) && fd >= 0){
         printf(1, "oops createdelete %s did exist\n", name);
-        exit();
+        exit(0);
       }
       if(fd >= 0)
         close(fd);
@@ -662,7 +662,7 @@ unlinkread(void)
   fd = open("unlinkread", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create unlinkread failed\n");
-    exit();
+    exit(0);
   }
   write(fd, "hello", 5);
   close(fd);
@@ -670,11 +670,11 @@ unlinkread(void)
   fd = open("unlinkread", O_RDWR);
   if(fd < 0){
     printf(1, "open unlinkread failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("unlinkread") != 0){
     printf(1, "unlink unlinkread failed\n");
-    exit();
+    exit(0);
   }
 
   fd1 = open("unlinkread", O_CREATE | O_RDWR);
@@ -683,15 +683,15 @@ unlinkread(void)
 
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "unlinkread read failed");
-    exit();
+    exit(0);
   }
   if(buf[0] != 'h'){
     printf(1, "unlinkread wrong data\n");
-    exit();
+    exit(0);
   }
   if(write(fd, buf, 10) != 10){
     printf(1, "unlinkread write failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
   unlink("unlinkread");
@@ -711,50 +711,50 @@ linktest(void)
   fd = open("lf1", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(1, "create lf1 failed\n");
-    exit();
+    exit(0);
   }
   if(write(fd, "hello", 5) != 5){
     printf(1, "write lf1 failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(link("lf1", "lf2") < 0){
     printf(1, "link lf1 lf2 failed\n");
-    exit();
+    exit(0);
   }
   unlink("lf1");
 
   if(open("lf1", 0) >= 0){
     printf(1, "unlinked lf1 but it is still there!\n");
-    exit();
+    exit(0);
   }
 
   fd = open("lf2", 0);
   if(fd < 0){
     printf(1, "open lf2 failed\n");
-    exit();
+    exit(0);
   }
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "read lf2 failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(link("lf2", "lf2") >= 0){
     printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit();
+    exit(0);
   }
 
   unlink("lf2");
   if(link("lf2", "lf1") >= 0){
     printf(1, "link non-existant succeeded! oops\n");
-    exit();
+    exit(0);
   }
 
   if(link(".", "lf1") >= 0){
     printf(1, "link . lf1 succeeded! oops\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "linktest ok\n");
@@ -765,7 +765,7 @@ void
 concreate(void)
 {
   char file[3];
-  int i, pid, n, fd;
+  int i, pid, n, fd, status;
   char fa[40];
   struct {
     ushort inum;
@@ -787,14 +787,14 @@ concreate(void)
       fd = open(file, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "concreate create %s failed\n", file);
-        exit();
+        exit(0);
       }
       close(fd);
     }
     if(pid == 0)
-      exit();
+      exit(0);
     else
-      wait();
+      wait(&status);
   }
 
   memset(fa, 0, sizeof(fa));
@@ -807,11 +807,11 @@ concreate(void)
       i = de.name[1] - '0';
       if(i < 0 || i >= sizeof(fa)){
         printf(1, "concreate weird file %s\n", de.name);
-        exit();
+        exit(0);
       }
       if(fa[i]){
         printf(1, "concreate duplicate file %s\n", de.name);
-        exit();
+        exit(0);
       }
       fa[i] = 1;
       n++;
@@ -821,7 +821,7 @@ concreate(void)
 
   if(n != 40){
     printf(1, "concreate not enough files in directory listing\n");
-    exit();
+    exit(0);
   }
 
   for(i = 0; i < 40; i++){
@@ -829,7 +829,7 @@ concreate(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(0);
     }
     if(((i % 3) == 0 && pid == 0) ||
        ((i % 3) == 1 && pid != 0)){
@@ -844,9 +844,9 @@ concreate(void)
       unlink(file);
     }
     if(pid == 0)
-      exit();
+      exit(0);
     else
-      wait();
+      wait(&status);
   }
 
   printf(1, "concreate ok\n");
@@ -857,7 +857,7 @@ concreate(void)
 void
 linkunlink()
 {
-  int pid, i;
+  int pid, i, status;
 
   printf(1, "linkunlink test\n");
 
@@ -865,7 +865,7 @@ linkunlink()
   pid = fork();
   if(pid < 0){
     printf(1, "fork failed\n");
-    exit();
+    exit(0);
   }
 
   unsigned int x = (pid ? 1 : 97);
@@ -881,9 +881,9 @@ linkunlink()
   }
 
   if(pid)
-    wait();
+    wait(&status);
   else
-    exit();
+    exit(0);
 
   printf(1, "linkunlink ok\n");
 }
@@ -901,7 +901,7 @@ bigdir(void)
   fd = open("bd", O_CREATE);
   if(fd < 0){
     printf(1, "bigdir create failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
@@ -912,7 +912,7 @@ bigdir(void)
     name[3] = '\0';
     if(link("bd", name) != 0){
       printf(1, "bigdir link failed\n");
-      exit();
+      exit(0);
     }
   }
 
@@ -924,7 +924,7 @@ bigdir(void)
     name[3] = '\0';
     if(unlink(name) != 0){
       printf(1, "bigdir unlink failed");
-      exit();
+      exit(0);
     }
   }
 
@@ -941,31 +941,31 @@ subdir(void)
   unlink("ff");
   if(mkdir("dd") != 0){
     printf(1, "subdir mkdir dd failed\n");
-    exit();
+    exit(0);
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/ff failed\n");
-    exit();
+    exit(0);
   }
   write(fd, "ff", 2);
   close(fd);
 
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit();
+    exit(0);
   }
 
   if(mkdir("/dd/dd") != 0){
     printf(1, "subdir mkdir dd/dd failed\n");
-    exit();
+    exit(0);
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/dd/ff failed\n");
-    exit();
+    exit(0);
   }
   write(fd, "FF", 2);
   close(fd);
@@ -973,142 +973,142 @@ subdir(void)
   fd = open("dd/dd/../ff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/../ff failed\n");
-    exit();
+    exit(0);
   }
   cc = read(fd, buf, sizeof(buf));
   if(cc != 2 || buf[0] != 'f'){
     printf(1, "dd/dd/../ff wrong content\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit();
+    exit(0);
   }
 
   if(unlink("dd/dd/ff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit();
+    exit(0);
   }
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit();
+    exit(0);
   }
 
   if(chdir("dd") != 0){
     printf(1, "chdir dd failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("dd/../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("dd/../../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("./..") != 0){
     printf(1, "chdir ./.. failed\n");
-    exit();
+    exit(0);
   }
 
   fd = open("dd/dd/ffff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/ffff failed\n");
-    exit();
+    exit(0);
   }
   if(read(fd, buf, sizeof(buf)) != 2){
     printf(1, "read dd/dd/ffff wrong len\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit();
+    exit(0);
   }
 
   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/ff/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/xx/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(open("dd", O_CREATE) >= 0){
     printf(1, "create dd succeeded!\n");
-    exit();
+    exit(0);
   }
   if(open("dd", O_RDWR) >= 0){
     printf(1, "open dd rdwr succeeded!\n");
-    exit();
+    exit(0);
   }
   if(open("dd", O_WRONLY) >= 0){
     printf(1, "open dd wronly succeeded!\n");
-    exit();
+    exit(0);
   }
   if(link("dd/ff/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(link("dd/xx/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(link("dd/ff", "dd/dd/ffff") == 0){
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(mkdir("dd/ff/ff") == 0){
     printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(mkdir("dd/xx/ff") == 0){
     printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(mkdir("dd/dd/ffff") == 0){
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd/xx/ff") == 0){
     printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd/ff/ff") == 0){
     printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(chdir("dd/ff") == 0){
     printf(1, "chdir dd/ff succeeded!\n");
-    exit();
+    exit(0);
   }
   if(chdir("dd/xx") == 0){
     printf(1, "chdir dd/xx succeeded!\n");
-    exit();
+    exit(0);
   }
 
   if(unlink("dd/dd/ffff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd/ff") != 0){
     printf(1, "unlink dd/ff failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd") == 0){
     printf(1, "unlink non-empty dd succeeded!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd/dd") < 0){
     printf(1, "unlink dd/dd failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("dd") < 0){
     printf(1, "unlink dd failed\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "subdir ok\n");
@@ -1127,14 +1127,14 @@ bigwrite(void)
     fd = open("bigwrite", O_CREATE | O_RDWR);
     if(fd < 0){
       printf(1, "cannot create bigwrite\n");
-      exit();
+      exit(0);
     }
     int i;
     for(i = 0; i < 2; i++){
       int cc = write(fd, buf, sz);
       if(cc != sz){
         printf(1, "write(%d) ret %d\n", sz, cc);
-        exit();
+        exit(0);
       }
     }
     close(fd);
@@ -1155,13 +1155,13 @@ bigfile(void)
   fd = open("bigfile", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "cannot create bigfile");
-    exit();
+    exit(0);
   }
   for(i = 0; i < 20; i++){
     memset(buf, i, 600);
     if(write(fd, buf, 600) != 600){
       printf(1, "write bigfile failed\n");
-      exit();
+      exit(0);
     }
   }
   close(fd);
@@ -1169,31 +1169,31 @@ bigfile(void)
   fd = open("bigfile", 0);
   if(fd < 0){
     printf(1, "cannot open bigfile\n");
-    exit();
+    exit(0);
   }
   total = 0;
   for(i = 0; ; i++){
     cc = read(fd, buf, 300);
     if(cc < 0){
       printf(1, "read bigfile failed\n");
-      exit();
+      exit(0);
     }
     if(cc == 0)
       break;
     if(cc != 300){
       printf(1, "short read bigfile\n");
-      exit();
+      exit(0);
     }
     if(buf[0] != i/2 || buf[299] != i/2){
       printf(1, "read bigfile wrong data\n");
-      exit();
+      exit(0);
     }
     total += cc;
   }
   close(fd);
   if(total != 20*600){
     printf(1, "read bigfile wrong total\n");
-    exit();
+    exit(0);
   }
   unlink("bigfile");
 
@@ -1210,32 +1210,32 @@ fourteen(void)
 
   if(mkdir("12345678901234") != 0){
     printf(1, "mkdir 12345678901234 failed\n");
-    exit();
+    exit(0);
   }
   if(mkdir("12345678901234/123456789012345") != 0){
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit();
+    exit(0);
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
   if(fd < 0){
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
   if(fd < 0){
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
   if(mkdir("12345678901234/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit();
+    exit(0);
   }
   if(mkdir("123456789012345/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "fourteen ok\n");
@@ -1247,35 +1247,35 @@ rmdot(void)
   printf(1, "rmdot test\n");
   if(mkdir("dots") != 0){
     printf(1, "mkdir dots failed\n");
-    exit();
+    exit(0);
   }
   if(chdir("dots") != 0){
     printf(1, "chdir dots failed\n");
-    exit();
+    exit(0);
   }
   if(unlink(".") == 0){
     printf(1, "rm . worked!\n");
-    exit();
+    exit(0);
   }
   if(unlink("..") == 0){
     printf(1, "rm .. worked!\n");
-    exit();
+    exit(0);
   }
   if(chdir("/") != 0){
     printf(1, "chdir / failed\n");
-    exit();
+    exit(0);
   }
   if(unlink("dots/.") == 0){
     printf(1, "unlink dots/. worked!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dots/..") == 0){
     printf(1, "unlink dots/.. worked!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dots") != 0){
     printf(1, "unlink dots failed!\n");
-    exit();
+    exit(0);
   }
   printf(1, "rmdot ok\n");
 }
@@ -1290,49 +1290,49 @@ dirfile(void)
   fd = open("dirfile", O_CREATE);
   if(fd < 0){
     printf(1, "create dirfile failed\n");
-    exit();
+    exit(0);
   }
   close(fd);
   if(chdir("dirfile") == 0){
     printf(1, "chdir dirfile succeeded!\n");
-    exit();
+    exit(0);
   }
   fd = open("dirfile/xx", 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   fd = open("dirfile/xx", O_CREATE);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(mkdir("dirfile/xx") == 0){
     printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dirfile/xx") == 0){
     printf(1, "unlink dirfile/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(link("README", "dirfile/xx") == 0){
     printf(1, "link to dirfile/xx succeeded!\n");
-    exit();
+    exit(0);
   }
   if(unlink("dirfile") != 0){
     printf(1, "unlink dirfile failed!\n");
-    exit();
+    exit(0);
   }
 
   fd = open(".", O_RDWR);
   if(fd >= 0){
     printf(1, "open . for writing succeeded!\n");
-    exit();
+    exit(0);
   }
   fd = open(".", 0);
   if(write(fd, "x", 1) > 0){
     printf(1, "write . succeeded!\n");
-    exit();
+    exit(0);
   }
   close(fd);
 
@@ -1351,11 +1351,11 @@ iref(void)
   for(i = 0; i < 50 + 1; i++){
     if(mkdir("irefd") != 0){
       printf(1, "mkdir irefd failed\n");
-      exit();
+      exit(0);
     }
     if(chdir("irefd") != 0){
       printf(1, "chdir irefd failed\n");
-      exit();
+      exit(0);
     }
 
     mkdir("");
@@ -1379,7 +1379,7 @@ iref(void)
 void
 forktest(void)
 {
-  int n, pid;
+  int n, pid, status;
 
   printf(1, "fork test\n");
 
@@ -1388,24 +1388,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(0);
   }
 
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
-    exit();
+    exit(0);
   }
 
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(&status) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(0);
     }
   }
 
-  if(wait() != -1){
+  if(wait(&status) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(0);
   }
 
   printf(1, "fork test OK\n");
@@ -1423,12 +1423,12 @@ sbrktest(void)
 
   // can one sbrk() less than a page?
   a = sbrk(0);
-  int i;
+  int i, status;
   for(i = 0; i < 5000; i++){
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit();
+      exit(0);
     }
     *b = 1;
     a = b + 1;
@@ -1436,17 +1436,17 @@ sbrktest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "sbrk test fork failed\n");
-    exit();
+    exit(0);
   }
   c = sbrk(1);
   c = sbrk(1);
   if(c != a + 1){
     printf(stdout, "sbrk test failed post-fork\n");
-    exit();
+    exit(0);
   }
   if(pid == 0)
-    exit();
-  wait();
+    exit(0);
+  wait(&status);
 
   // can one grow address space to something big?
 #define BIG (100*1024*1024)
@@ -1455,7 +1455,7 @@ sbrktest(void)
   p = sbrk(amt);
   if (p != a) {
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit();
+    exit(0);
   }
   lastaddr = (char*) (BIG-1);
   *lastaddr = 99;
@@ -1465,12 +1465,12 @@ sbrktest(void)
   c = sbrk(-4096);
   if(c == (char*)0xffffffff){
     printf(stdout, "sbrk could not deallocate\n");
-    exit();
+    exit(0);
   }
   c = sbrk(0);
   if(c != a - 4096){
     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit();
+    exit(0);
   }
 
   // can one re-allocate that page?
@@ -1478,19 +1478,19 @@ sbrktest(void)
   c = sbrk(4096);
   if(c != a || sbrk(0) != a + 4096){
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit();
+    exit(0);
   }
   if(*lastaddr == 99){
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit();
+    exit(0);
   }
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
   if(c != a){
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit();
+    exit(0);
   }
 
   // can we read the kernel's memory?
@@ -1499,21 +1499,21 @@ sbrktest(void)
     pid = fork();
     if(pid < 0){
       printf(stdout, "fork failed\n");
-      exit();
+      exit(0);
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
-      exit();
+      exit(0);
     }
-    wait();
+    wait(&status);
   }
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit();
+    exit(0);
   }
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if((pids[i] = fork()) == 0){
@@ -1533,11 +1533,11 @@ sbrktest(void)
     if(pids[i] == -1)
       continue;
     kill(pids[i]);
-    wait();
+    wait(&status);
   }
   if(c == (char*)0xffffffff){
     printf(stdout, "failed sbrk leaked memory\n");
-    exit();
+    exit(0);
   }
 
   if(sbrk(0) > oldbrk)
@@ -1562,7 +1562,7 @@ validateint(int *p)
 void
 validatetest(void)
 {
-  int hi, pid;
+  int hi, pid, status;
   uint p;
 
   printf(stdout, "validate test\n");
@@ -1572,17 +1572,17 @@ validatetest(void)
     if((pid = fork()) == 0){
       // try to crash the kernel by passing in a badly placed integer
       validateint((int*)p);
-      exit();
+      exit(0);
     }
     sleep(0);
     sleep(0);
     kill(pid);
-    wait();
+    wait(&status);
 
     // try to crash the kernel by passing in a bad string pointer
     if(link("nosuchfile", (char*)p) != -1){
       printf(stdout, "link should not succeed\n");
-      exit();
+      exit(0);
     }
   }
 
@@ -1600,7 +1600,7 @@ bsstest(void)
   for(i = 0; i < sizeof(uninit); i++){
     if(uninit[i] != '\0'){
       printf(stdout, "bss test failed\n");
-      exit();
+      exit(0);
     }
   }
   printf(stdout, "bss test ok\n");
@@ -1612,7 +1612,7 @@ bsstest(void)
 void
 bigargtest(void)
 {
-  int pid, fd;
+  int pid, fd, status;
 
   unlink("bigarg-ok");
   pid = fork();
@@ -1627,16 +1627,16 @@ bigargtest(void)
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
-    exit();
+    exit(0);
   } else if(pid < 0){
     printf(stdout, "bigargtest: fork failed\n");
-    exit();
+    exit(0);
   }
-  wait();
+  wait(&status);
   fd = open("bigarg-ok", 0);
   if(fd < 0){
     printf(stdout, "bigarg test failed!\n");
-    exit();
+    exit(0);
   }
   close(fd);
   unlink("bigarg-ok");
@@ -1703,7 +1703,7 @@ uio()
 
   ushort port = 0;
   uchar val = 0;
-  int pid;
+  int pid, status;
 
   printf(1, "uio test\n");
   pid = fork();
@@ -1715,12 +1715,12 @@ uio()
     port = RTC_DATA;
     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
     printf(1, "uio: uio succeeded; test FAILED\n");
-    exit();
+    exit(0);
   } else if(pid < 0){
     printf (1, "fork failed\n");
-    exit();
+    exit(0);
   }
-  wait();
+  wait(&status);
   printf(1, "uio test done\n");
 }
 
@@ -1730,7 +1730,7 @@ void argptest()
   fd = open("init", O_RDONLY);
   if (fd < 0) {
     printf(2, "open failed\n");
-    exit();
+    exit(0);
   }
   read(fd, sbrk(0) - 1, -1);
   close(fd);
@@ -1752,7 +1752,7 @@ main(int argc, char *argv[])
 
   if(open("usertests.ran", 0) >= 0){
     printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit();
+    exit(0);
   }
   close(open("usertests.ran", O_CREATE));
 
@@ -1799,5 +1799,5 @@ main(int argc, char *argv[])
 
   exectest();
 
-  exit();
+  exit(0);
 }
diff --git a/usys.S b/usys.S
index 8bfd8a1..e99ad50 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,8 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(memsize)
+SYSCALL(set_ps_priority)
+SYSCALL(set_cfs_priority)
+SYSCALL(policy)
+SYSCALL(proc_info)
\ No newline at end of file
diff --git a/wc.c b/wc.c
index d6a54df..1d4f708 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit();
+    exit(0);
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit();
+    exit(0);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
+      exit(0);
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit();
+  exit(0);
 }
diff --git a/zombie.c b/zombie.c
index ee817da..c96b92d 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit();
+  exit(0);
 }
